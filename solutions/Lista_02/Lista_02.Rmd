---
title: "Métodos Numéricos 2018 - Lista 02"
output:
  html_document:
    df_print: paged
---

```{r include=FALSE}
library(data.table)
library(tictoc)
```


Nesta lista vamos solucionar o modelo de *Real Business Cycles* (RBC) usando diferentes
técnicas de iteração da função valor.

### Preferências

$$ U(c) = \mathbb{E}_0 \sum_{t=0}^{\infty} \beta^t u(c_t) $$

$$ u(c_t) = \frac{c^{1-\mu}-1}{1-\mu}$$
$$\mu = 1/(1+r)$$

### Tecnologia

$$Y_t = z_t F(K_t, N_t) = z_t K_t^\alpha N_t^{1-\alpha}$$

$$ \log z_t = \rho \log z_{t-1} + \epsilon_t $$

$$ \varepsilon_t \sim N(0, \sigma^2) $$

### Calibração


$$\beta = 0.987$$
$$\mu=2$$
$$\alpha=0.3$$
$$\delta=0.012$$
$$\rho=0.95$$
$$\sigma=0.007$$
<br>

#### 1. Escreva o problema do planejador na forma recursiva

<br>

O problema do planejador consiste em maximizar $U(c)$ sujeito à restrição de
factibilidade $Y_t = C_t + S_t$ e à lei de movimento do capital 
$K_{t+1} = (1-\delta)K_t + S_t$.

Podemos escrever este problema na forma recursiva como

\begin{equation}
\begin{aligned}
& V(k,z) = \max_{k', \, c} & & u(c) + \beta \mathbb{E} V(k',z'). \\
& \text{s.a.} & & c = y - s \\
&             & & k' = (1-\delta)k + s
\end{aligned}
\end{equation}


Equivalentemente,

\begin{equation}
\begin{aligned}
& V(k,z) = \max_{k' \geq 0} & & u(zk^\alpha + (1-\delta)k - k') + \beta \mathbb{E} V(k',z')
\end{aligned}
\end{equation}

<br>

#### 2. Assuma que não há incerteza, i.e., $\sigma = 0$. Derive a equação de Euler e encontre o capital de estado estacionário $k_{ss}$.

<br>

Da condição de otimalidade e Teorema do Envelope obtemos a eq. de Euler:


\begin{equation}
\begin{aligned}
u'(c) & = & & \beta  \mathbb{E} [ \frac{\partial}{\partial k'} V(k',z')] \\
      & = & & \beta u'(c') \mathbb{E} (\alpha z k^{\alpha-1} + 1 - \delta).
\end{aligned}
\end{equation}


<br>

No estado estacionário, sem incerteza, temos $c'=c=c_{ss}$ e $k'=k=k_{ss}$. 
Além disso, 

\begin{equation}
\begin{aligned}
&  &\log(z_t)  = \rho \log(z_{t-1}) + \epsilon_t \\
&     \implies  & (1-\rho L) \log(z_t) = \epsilon_t = 0 \\
&     \implies  &  \log(z_t) =  0 \\
&     \implies &  z_t =  1. \\
\end{aligned}
\end{equation}

Logo

\begin{equation}
\begin{aligned}
1 & = & & \beta (\alpha k_{ss}^{\alpha-1} + 1 - \delta)  \iff \\
k_{ss}^{1-\alpha} & = & & \frac{1-\beta(1-\delta)}{\alpha \beta} \iff \\
k_{ss}            & = & & \left[ \frac{1-\beta(1-\delta)}{\alpha \beta} \right] ^ {\frac{1}{\alpha-1}}
\end{aligned}
\end{equation}


#### 3. Resolva o problema utilizando método de iteração da função valor.

Para a choque de TFP, vamos utilizar o método de Tauchen (1986) com
7 pontos. Para o grid de capital, usaremos 500 pontos linearmente espaçados
no intervalo $[0.75 k_{ss}, 1.25 k_{ss}]$.


```{r}
# Ambiente
beta   = 0.987
mu     = 2
alpha  = 0.3
delta  = 0.012
rho    = 0.95
sigma  = 0.007

# Estado estacionario
kss = ((1-beta*(1-delta))/(alpha*beta))^(1/(alpha-1))

# Grids
source("tauchen.R")
z_grid = tauchen_grid(N=7, m=3, sigma, rho)
P = tauchen_P(z_grid, rho, sigma, mu)
k_grid = seq(0.75*kss, 1.25*kss, length.out = 500)
```

##### Força bruta

Vamos iniciar com o método da força bruta como "benchmark".

```{r}
u = function(c) (c^(1-mu) - 1) / (1-mu)

# Grids OK
K  = t(kronecker(k_grid, matrix(1,1,500)))
KP = kronecker(rev(k_grid), matrix(1,1,500))

# Consumo e utilidade OK
Y = K^alpha %o% z_grid
S = KP %o% rep(1,7) - (1-delta) * (K %o% rep(1,7))
C = Y - S
C[C<0] = 0.001
U = u(C)

# Chute inicial para a função valor em cada um dos 7 estados
V0 = rep(0, 500) %o% rep(1,7)
#dim(V0)

# Matriz de transição organizada em tensor
bigP = P %o% rep(1,500)
bigP = aperm(bigP, c(3,1,2))
#dim(bigP) # k, i, j

it=1
err=1
tol=10^-5
itmax=1000

tic("Tempo até convergir: \n")
while(err>tol & it<itmax) {
  EV = rowSums(bigP * (V0 %o% rep(1,7)), dims = 2)
  EV = rep(1, 500) %o% EV
  H = U + beta * EV
  V = apply(H, c(1,3), max)
  err=max(apply(abs(V-V0), 2, max))
  # print(err)
  it=it+1
  V0 = V
}
toc()

```


```{r echo=FALSE, message=FALSE, warning=FALSE}
library(tidyverse)
library(ggplot2)
tbl = data.frame(k_grid, V)
tbl = tbl %>% gather(key = "state", value = "value", X1:X7)
tbl$state = gsub("X", "", tbl$state)
tbl %>% 
  filter(k_grid>29) %>% 
  ggplot(aes(k_grid, value, col = state)) +
  geom_line() +
  xlab("k") +
  ylab("V(k,z)") + 
  theme_classic() +
  theme(axis.title.y = 
          element_text(angle=0, vjust = 0.5)) +
  scale_colour_brewer(guide=FALSE)
```

